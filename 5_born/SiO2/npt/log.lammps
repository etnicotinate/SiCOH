LAMMPS (2 Aug 2023 - Update 2)
  using 6 OpenMP thread(s) per MPI task
timer timeout 0 every 1
New timer settings: style=normal  mode=nosync  timeout=00:00:00

include init.in

# set log file
# log log.elastic

# Define MD parameters
variable nevery equal 5                 # sampling interval
variable nrepeat equal 20                 # times to use input values for calculating averages
variable nfreq equal ${nevery}*${nrepeat} # length of one average
variable nfreq equal 5*${nrepeat} 
variable nfreq equal 5*20 
variable nthermo equal ${nfreq}           # interval for thermo output: 100
variable nthermo equal 100           

variable temp equal 300.0                # temperature of initial sample
variable timestep equal 0.5               # timestep
variable adiabatic equal 2                # adiabatic (1) or isothermal (2)
variable tdamp equal 50.0                 # time constant for temperature
variable pdamp equal 10*${tdamp}          # time constant for pressure
variable pdamp equal 10*50          
variable up equal 2.0e-3                  # the deformation magnitude
variable thermostat equal 1               # 0 if NVE, 1 if NPT, 2 if NVT
variable delta index 1.0e-6               # Born numdiff strain magnitude

# read initial structure
units           real
dimension       3
boundary        p p p
atom_style      full

# read initial structure
# read_data 333SiO2-1-UFF-c_eq.data
read_data 333SiO2-1-UFF-c.data
Reading data file ...
  triclinic box = (0 0 0) to (14.6913 12.723 15.9631) with tilt (-7.3456 0 0)
WARNING: Triclinic box skew is large. LAMMPS will run inefficiently. (src/domain.cpp:220)
  1 by 1 by 2 MPI processor grid
  reading atoms ...
  243 atoms
Finding 1-2 1-3 1-4 neighbors ...
  special bond factors lj:    0        0        0       
  special bond factors coul:  0        0        0       
     0 = max # of 1-2 neighbors
     0 = max # of 1-3 neighbors
     0 = max # of 1-4 neighbors
     1 = max # of special neighbors
  special bonds CPU = 0.000 seconds
  read_data CPU = 0.005 seconds
variable nequil equal 1000*${nthermo}       # length of equilibration run 1000
variable nequil equal 1000*100       
variable nrun equal 1000*${nthermo}          # length of equilibrated run
variable nrun equal 1000*100          
variable seed index 123457                # seed for thermostat 123456

thermo ${nthermo}
thermo 100
thermo_style custom step temp pe press

# Energy minimization
print "##### Minimization starts."
##### Minimization starts.
minimize 1.0e-6 1.0e-6 100 1000
min_style cg
# Save the optimized structure
write_data sio2_opt.data
System init for write_data ...
WARNING: Communication cutoff is 0.0. No ghost atoms will be generated. Atoms may get lost. (src/comm_brick.cpp:210)
reset_timestep 0
timestep ${timestep}
timestep 0.5

velocity        all create ${temp} ${seed} dist gaussian
velocity        all create 300 ${seed} dist gaussian
velocity        all create 300 123457 dist gaussian
# equilibration
variable thermostat equal 1               # 0 if NVE, 1 if NPT, 2 if NVT
print "equil: ${thermostat}"
equil: 1
include ff.in
if "$(is_defined(fix,5))" then "unfix 5"
if "$(is_defined(fix,6))" then "unfix 6"
reset_timestep 0

# Assign the force field
pair_style reaxff NULL safezone 3.0 mincap 150
# pair_coeff * * CHONSSi.ff O Si
# pair_coeff * * CHOSiNa.ff O Si
# pair_coeff * * SiOCHN_2018.ff O Si
# pair_coeff * * PDMSDecomp.ff Si O
# pair_coeff * * CHONSi.ff C H O Si
pair_coeff * * CHOFe.ff O Si
WARNING: Van der Waals parameters for element SI indicate inner wall+shielding, but earlier atoms indicate a different van der Waals method. This may cause division-by-zero errors. Keeping van der Waals setting for earlier atoms. (src/REAXFF/reaxff_ffield.cpp:251)
WARNING: Van der Waals parameters for element AL indicate inner wall+shielding, but earlier atoms indicate a different van der Waals method. This may cause division-by-zero errors. Keeping van der Waals setting for earlier atoms. (src/REAXFF/reaxff_ffield.cpp:251)
WARNING: Changed valency_val to valency_boc for X (src/REAXFF/reaxff_ffield.cpp:296)

# charge method for reaxff
fix myqeq all qeq/reaxff 1 0.0 10.0 1.0e-6 reaxff maxiter 400
# Setup neighbor style
neighbor        2 bin
neigh_modify    every 10 delay 0 check no

# Setup MD
# 0 if NVE, 1 if NPT, 2 if NVT

if "${thermostat} == 0" then    "fix 4 all nve" elif "${thermostat} == 1"    "fix 5 all npt temp ${temp} ${temp} ${tdamp} tri 1.0 1.0 ${pdamp}" elif "${thermostat} == 2"    "fix 6 all nvt temp ${temp} ${temp} ${tdamp}"
fix 5 all npt temp ${temp} ${temp} ${tdamp} tri 1.0 1.0 ${pdamp}
fix 5 all npt temp 300 ${temp} ${tdamp} tri 1.0 1.0 ${pdamp}
fix 5 all npt temp 300 300 ${tdamp} tri 1.0 1.0 ${pdamp}
fix 5 all npt temp 300 300 50 tri 1.0 1.0 ${pdamp}
fix 5 all npt temp 300 300 50 tri 1.0 1.0 500
print "md: ${thermostat}"
md: 1
# save trajectory
dump dump_opt all custom ${nthermo} dump_opt.lammpstrj id type x y z
dump dump_opt all custom 100 dump_opt.lammpstrj id type x y z
run ${nequil}
run 100000
write_data sio2_eq.data
System init for write_data ...
Neighbor list info ...
  update: every = 10 steps, delay = 0 steps, check = no
  max neighbors/atom: 2000, page size: 100000
  master list distance cutoff = 12
  ghost atom cutoff = 12
  binsize = 6, bins = 4 3 3
  2 neighbor lists, perpetual/occasional/extra = 2 0 0
  (1) pair reaxff, perpetual
      attributes: half, newton off, ghost
      pair build: half/bin/newtoff/ghost
      stencil: full/ghost/bin/3d
      bin: standard
  (2) fix qeq/reaxff, perpetual, copy from (1)
      attributes: half, newton off
      pair build: copy
      stencil: none
      bin: none
undump dump_opt
reset_timestep 0

variable thermostat equal 2               # 0 if NVE, 1 if NPT, 2 if NVT
print "##### Main run: ${thermostat}"
##### Main run: 2
include ff.in
if "$(is_defined(fix,5))" then "unfix 5"
unfix 5
if "$(is_defined(fix,6))" then "unfix 6"
reset_timestep 0

# Assign the force field
pair_style reaxff NULL safezone 3.0 mincap 150
# pair_coeff * * CHONSSi.ff O Si
# pair_coeff * * CHOSiNa.ff O Si
# pair_coeff * * SiOCHN_2018.ff O Si
# pair_coeff * * PDMSDecomp.ff Si O
# pair_coeff * * CHONSi.ff C H O Si
pair_coeff * * CHOFe.ff O Si
WARNING: Van der Waals parameters for element SI indicate inner wall+shielding, but earlier atoms indicate a different van der Waals method. This may cause division-by-zero errors. Keeping van der Waals setting for earlier atoms. (src/REAXFF/reaxff_ffield.cpp:251)
WARNING: Van der Waals parameters for element AL indicate inner wall+shielding, but earlier atoms indicate a different van der Waals method. This may cause division-by-zero errors. Keeping van der Waals setting for earlier atoms. (src/REAXFF/reaxff_ffield.cpp:251)
WARNING: Changed valency_val to valency_boc for X (src/REAXFF/reaxff_ffield.cpp:296)

# charge method for reaxff
fix myqeq all qeq/reaxff 1 0.0 10.0 1.0e-6 reaxff maxiter 400
# Setup neighbor style
neighbor        2 bin
neigh_modify    every 10 delay 0 check no

# Setup MD
# 0 if NVE, 1 if NPT, 2 if NVT

if "${thermostat} == 0" then    "fix 4 all nve" elif "${thermostat} == 1"    "fix 5 all npt temp ${temp} ${temp} ${tdamp} tri 1.0 1.0 ${pdamp}" elif "${thermostat} == 2"    "fix 6 all nvt temp ${temp} ${temp} ${tdamp}"
fix 6 all nvt temp ${temp} ${temp} ${tdamp}
fix 6 all nvt temp 300 ${temp} ${tdamp}
fix 6 all nvt temp 300 300 ${tdamp}
fix 6 all nvt temp 300 300 50
print "md: ${thermostat}"
md: 2
include calc.in
# Setup output
# Born term, 2nd derivative of energy
compute     vir all pressure NULL virial
compute     born all born/matrix numdiff ${delta} vir
compute     born all born/matrix numdiff 1.0e-6 vir
fix 	    avborn all ave/time ${nevery} ${nrepeat} ${nfreq} c_born[*] ave running             file born.out
fix 	    avborn all ave/time 5 ${nrepeat} ${nfreq} c_born[*] ave running             file born.out
fix 	    avborn all ave/time 5 20 ${nfreq} c_born[*] ave running             file born.out
fix 	    avborn all ave/time 5 20 100 c_born[*] ave running             file born.out
fix         avvir all ave/time 1 1 1 c_vir[*]             file vir.out

thermo		${nthermo}
thermo		100
thermo_style custom step temp pe press
thermo_modify norm no


# save trajectory
dump dump_main all custom ${nthermo} dump_main.lammpstrj id type x y z
dump dump_main all custom 100 dump_main.lammpstrj id type x y z
run ${nrun}
run 100000

# summarize sampling protocol
print "Stress sampling interval = ${nevery}"
Stress sampling interval = 5
variable tmp equal ${nrun}/${nevery}
variable tmp equal 100000/${nevery}
variable tmp equal 100000/5
print "Stress sample count = ${tmp}"
Stress sample count = 20000
print "Born sampling interval = ${nevery}"
Born sampling interval = 5
variable tmp equal ${nrun}/${nevery}
variable tmp equal 100000/${nevery}
variable tmp equal 100000/5
print "Born sample count = ${tmp}"
Born sample count = 20000

# output the result
# print ""
# print "Output the tensor to C.lmp.log"

# print "${C11} ${C12} ${C13} ${C14} ${C15} ${C16}" #     file "C.lmp.log" screen no
# print "${C12} ${C22} ${C23} ${C24} ${C25} ${C26}"#     append "C.lmp.log" screen no
# print "${C13} ${C23} ${C33} ${C34} ${C35} ${C36}"#     append "C.lmp.log" screen no
# print "${C14} ${C24} ${C34} ${C44} ${C45} ${C46}"#     append "C.lmp.log" screen no
# print "${C15} ${C25} ${C35} ${C45} ${C55} ${C56}"#     append "C.lmp.log" screen no
# print "${C16} ${C26} ${C36} ${C46} ${C56} ${C66}"#     append "C.lmp.log" screen no

print "done!"
done!

CITE-CITE-CITE-CITE-CITE-CITE-CITE-CITE-CITE-CITE-CITE-CITE-CITE

Your simulation uses code contributions which should be cited:

- pair reaxff command: doi:10.1016/j.parco.2011.08.005

@Article{Aktulga12,
 author = {H. M. Aktulga and J. C. Fogarty and S. A. Pandit and A. Y. Grama},
 title = {Parallel Reactive Molecular Dynamics: {N}umerical Methods and Algorithmic Techniques},
 journal = {Parallel Computing},
 year =    2012,
 volume =  38,
 number =  {4--5},
 pages =   {245--259}
}

- fix qeq/reaxff command: doi:10.1016/j.parco.2011.08.005

@Article{Aktulga12,
 author = {H. M. Aktulga and J. C. Fogarty and S. A. Pandit and A. Y. Grama},
 title = {Parallel Reactive Molecular Dynamics: {N}umerical Methods and Algorithmic Techniques},
 journal = {Parallel Computing},
 year =    2012,
 volume =  38,
 pages =   {245--259}
}

CITE-CITE-CITE-CITE-CITE-CITE-CITE-CITE-CITE-CITE-CITE-CITE-CITE

Total wall time: 0:00:00
